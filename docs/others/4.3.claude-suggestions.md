# Story 4.3 Implementation Guide

## Overview
This document provides implementation details and best practices for Story 4.3, which adds functionality for assigning work items to future sprints.

## Key Components Implementation

### 1. Sprint Assignment Service
The sprint assignment service handles the core logic for assigning work items to sprints.

```typescript
class SprintAssignmentService {
  /**
   * Validates and assigns a work item to a sprint
   * @throws {InvalidSprintStatusError} If sprint is not in FUTURE status
   * @throws {ConcurrentModificationError} If work item was modified
   * @throws {UnauthorizedError} If user lacks permissions
   */
  async assignToSprint(workItemId: string, sprintId: string): Promise<WorkItem> {
    // Validation and business logic implementation
  }
}
```

### 2. Data Versioning
Implement optimistic concurrency control using version numbers:

```typescript
interface WorkItem {
  id: string;
  version: number;
  sprintId: string | null;
  // ... other fields
}

class WorkItemRepository {
  async update(workItem: WorkItem): Promise<WorkItem> {
    const result = await db.workItems.updateOne(
      { 
        id: workItem.id, 
        version: workItem.version 
      },
      { 
        $set: { ...workItem, version: workItem.version + 1 }
      }
    );
    
    if (!result.modifiedCount) {
      throw new ConcurrentModificationError();
    }
    
    return result;
  }
}
```

### 3. Real-time Updates
Use WebSocket for real-time state synchronization:

```typescript
class WorkItemUpdateService {
  private ws: WebSocket;

  constructor() {
    this.ws = new WebSocket(WS_URL);
    this.setupEventHandlers();
  }

  private setupEventHandlers() {
    this.ws.onmessage = (event) => {
      const update = JSON.parse(event.data);
      if (update.type === 'WORK_ITEM_UPDATED') {
        this.handleWorkItemUpdate(update.payload);
      }
    };
  }

  private handleWorkItemUpdate(payload: WorkItemUpdate) {
    // Update local state and UI
  }
}
```

## Test Implementation

### 1. Unit Tests
Focus on individual component behavior:

```typescript
describe('SprintAssignmentService', () => {
  it('should validate sprint status', async () => {
    const service = new SprintAssignmentService();
    await expect(
      service.assignToSprint('work-1', 'active-sprint')
    ).rejects.toThrow(InvalidSprintStatusError);
  });
});
```

### 2. Integration Tests
Test component interactions:

```typescript
describe('Sprint Assignment Integration', () => {
  it('should handle concurrent modifications', async () => {
    const service = new SprintAssignmentService();
    const repo = new WorkItemRepository();
    
    // Setup concurrent operations
    const op1 = service.assignToSprint('work-1', 'sprint-1');
    const op2 = service.assignToSprint('work-1', 'sprint-2');
    
    // Verify conflict handling
    await expect(Promise.all([op1, op2])).rejects.toThrow(ConcurrentModificationError);
  });
});
```

### 3. E2E Tests
Verify complete workflows:

```typescript
describe('Sprint Assignment E2E', () => {
  it('should complete full assignment workflow', async () => {
    // Setup test data
    const workItem = await createTestWorkItem();
    const sprint = await createTestSprint();
    
    // Perform assignment
    await assignToSprint(workItem.id, sprint.id);
    
    // Verify final state
    const updatedItem = await getWorkItem(workItem.id);
    expect(updatedItem.sprintId).toBe(sprint.id);
  });
});
```

## Performance Considerations

1. **Optimistic Concurrency**
   - Use version numbers for conflict detection
   - Avoid unnecessary locks
   - Handle conflicts at the application level

2. **Real-time Updates**
   - Implement debouncing for high-frequency updates
   - Use message deduplication
   - Implement reconnection logic

3. **Caching**
   - Cache sprint status information
   - Implement cache invalidation on sprint status changes
   - Use local state for UI updates

## Security Considerations

1. **Authentication**
   - Validate user session for each operation
   - Implement token refresh logic
   - Handle session expiration gracefully

2. **Authorization**
   - Check user roles and permissions
   - Validate team membership
   - Implement fine-grained access control

3. **Data Validation**
   - Validate input data
   - Sanitize user input
   - Implement request rate limiting

## Error Handling

1. **Business Logic Errors**
```typescript
class InvalidSprintStatusError extends Error {
  constructor(sprintId: string, status: SprintStatus) {
    super(`Sprint ${sprintId} is in ${status} status. Only FUTURE sprints can be assigned.`);
  }
}
```

1. **Concurrency Errors**
```typescript
class ConcurrentModificationError extends Error {
  constructor(workItemId: string) {
    super(`Work item ${workItemId} was modified by another user.`);
  }
}
```

1. **Authorization Errors**
```typescript
class InsufficientPermissionsError extends Error {
  constructor(requiredRole: string) {
    super(`User requires ${requiredRole} role for this operation.`);
  }
}
```

## Best Practices

1. **Code Organization**
   - Group related functionality
   - Follow single responsibility principle
   - Use dependency injection

2. **Testing**
   - Write tests first (TDD)
   - Cover edge cases
   - Test error scenarios

3. **Documentation**
   - Document public APIs
   - Include examples
   - Keep docs up to date

## Changelog
| Date | Version | Changes | Author |
|------|----------|---------|--------|
| 2025-09-24 | 1.0 | Initial implementation guide | Dev Persona (Claude) |
