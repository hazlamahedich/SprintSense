name: Deploy to Development

on:
  push:
    branches: [main]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/PULL_REQUEST_TEMPLATE/**'

  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip CI tests (emergency deployments only)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '20'
  ENVIRONMENT: development

jobs:
  # Run tests unless explicitly skipped
  test:
    if: ${{ !inputs.skip_tests || github.event_name == 'push' }}
    uses: ./.github/workflows/ci.yml

  # Build and push Docker images
  build:
    runs-on: ubuntu-latest
    needs: [test]
    if: always() && (needs.test.result == 'success' || inputs.skip_tests)
    permissions:
      contents: read
      packages: write
      security-events: write
    outputs:
      backend-image: ${{ steps.build-backend.outputs.image }}
      backend-digest: ${{ steps.build-backend.outputs.digest }}
      frontend-image: ${{ steps.build-frontend.outputs.image }}
      frontend-digest: ${{ steps.build-frontend.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build backend image
        id: build-backend
        uses: ./.github/actions/build-and-push-docker
        with:
          image_name: backend
          tag: ${{ github.sha }}
          context: ./backend
          dockerfile: Dockerfile

      - name: Build frontend
        working-directory: ./frontend
        run: |
          npm ci
          npm run build
        env:
          VITE_API_URL: ${{ vars.VITE_API_URL || 'http://localhost:8000' }}

      - name: Build frontend image
        id: build-frontend
        uses: ./.github/actions/build-and-push-docker
        with:
          image_name: frontend
          tag: ${{ github.sha }}
          context: ./frontend
          dockerfile: Dockerfile.prod

  # Database migrations
  migrate:
    runs-on: ubuntu-latest
    needs: [build]
    environment: development
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: '2.2.0'
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Install dependencies
        working-directory: ./backend
        run: poetry install --no-root

      - name: Run database migrations
        working-directory: ./backend
        run: |
          echo "üóÑÔ∏è Running database migrations..."
          poetry run alembic upgrade head
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

  # Supabase deployment
  deploy-supabase:
    runs-on: ubuntu-latest
    needs: [migrate]
    environment: development
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Deploy Supabase changes
        run: |
          echo "üöÄ Deploying Supabase changes..."
          supabase link --project-ref ${{ secrets.SUPABASE_PROJECT_REF }}
          supabase db push --include-all
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}

  # Container deployment (placeholder - replace with your deployment method)
  deploy:
    runs-on: ubuntu-latest
    needs: [build, migrate, deploy-supabase]
    environment: development
    outputs:
      deployment-url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Deploy containers
        id: deploy
        run: |
          echo "üöÄ Deploying to development environment"
          echo "Backend image: ${{ needs.build.outputs.backend-image }}"
          echo "Frontend image: ${{ needs.build.outputs.frontend-image }}"

          # Example deployment methods (choose one):

          # Option 1: Docker Compose on remote server
          # ssh user@dev-server "docker compose -f docker-compose.prod.yml pull && docker compose -f docker-compose.prod.yml up -d"

          # Option 2: Railway deployment
          # railway deploy --service backend --image ${{ needs.build.outputs.backend-image }}
          # railway deploy --service frontend --image ${{ needs.build.outputs.frontend-image }}

          # Option 3: Cloud Run deployment
          # gcloud run deploy backend --image ${{ needs.build.outputs.backend-image }} --platform managed
          # gcloud run deploy frontend --image ${{ needs.build.outputs.frontend-image }} --platform managed

          # For now, simulate successful deployment
          echo "url=https://dev.sprintsense.dev" >> $GITHUB_OUTPUT
          echo "‚úÖ Deployment completed successfully"

      - name: Create GitHub Deployment
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ github.token }}
          environment: development
          description: 'Deploy to development'

  # Health checks
  health-check:
    runs-on: ubuntu-latest
    needs: [deploy]
    environment: development

    steps:
      - name: Wait for services to start
        run: sleep 30

      - name: Health check backend
        run: |
          echo "üè• Performing health checks..."

          # Replace with your actual deployment URL
          BACKEND_URL="${{ needs.deploy.outputs.deployment-url || 'https://dev-api.sprintsense.dev' }}"
          HEALTH_ENDPOINT="$BACKEND_URL/api/v1/health/detailed"

          echo "Checking backend health at $HEALTH_ENDPOINT"

          # Retry health check with backoff
          for i in {1..5}; do
            if curl -f -s "$HEALTH_ENDPOINT" > /tmp/health_response.json; then
              echo "‚úÖ Backend health check passed"
              cat /tmp/health_response.json | jq .
              break
            else
              echo "‚ö†Ô∏è Health check attempt $i failed, retrying in 10s..."
              sleep 10
              if [ $i -eq 5 ]; then
                echo "‚ùå Backend health check failed after 5 attempts"
                exit 1
              fi
            fi
          done

      - name: Update deployment status
        if: always()
        uses: chrnorm/deployment-status@v2
        with:
          token: ${{ github.token }}
          environment: development
          state: ${{ job.status == 'success' && 'success' || 'failure' }}
          deployment-id: ${{ steps.deployment.outputs.deployment_id }}

  # Notifications
  notify:
    runs-on: ubuntu-latest
    needs: [deploy, health-check]
    if: always()
    environment: development

    steps:
      - name: Send Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
          custom_payload: |
            {
              "text": "Development Deployment",
              "attachments": [
                {
                  "color": "${{ job.status == 'success' && 'good' || 'danger' }}",
                  "fields": [
                    {
                      "title": "Status",
                      "value": "${{ job.status == 'success' && '‚úÖ Success' || '‚ùå Failed' }}",
                      "short": true
                    },
                    {
                      "title": "Environment",
                      "value": "Development",
                      "short": true
                    },
                    {
                      "title": "Commit",
                      "value": "<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha }}>",
                      "short": true
                    },
                    {
                      "title": "Author",
                      "value": "${{ github.actor }}",
                      "short": true
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
