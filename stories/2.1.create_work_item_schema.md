# Story 2.1: Create Work Item Schema

## Status
Draft

## Story
**As a** Developer,
**I want** to create the database schema for work items,
**so that** we can store backlog data.

## Acceptance Criteria
1. A new database migration is created for the `work_items` table.
2. The schema is applied to the database.

## Tasks / Subtasks
**IMPORTANT**: Tasks must be executed in sequence due to dependencies: 1‚Üí2‚Üí3‚Üí4‚Üí5

- [ ] **1. Create Database Migration for Work Items Table (AC: #1)**
    - [ ] Create Alembic migration file using `alembic revision --autogenerate -m "add work_items table"`
    - [ ] Create migration for `work_items` table with `id` (UUID), `team_id` (FK), `sprint_id` (FK, nullable), `author_id` (FK), `assignee_id` (FK, nullable), `type` (enum: 'story', 'bug', 'task'), `title` (string), `description` (string, nullable), `status` (enum: 'backlog', 'todo', 'in_progress', 'done', 'archived'), `priority` (float), `story_points` (integer, nullable), `completed_at` (Date, nullable), `created_at` (Date), `updated_at` (Date), `source_sprint_id_for_action_item` (FK, nullable)
    - [ ] Add proper foreign key constraints to teams and users tables
    - [ ] Leave Sprint FK constraints for future implementation (Sprint model will be created in Epic 4)
    - [ ] Add database indexes on frequently queried columns (team_id, status, priority)
    - [ ] Apply migration to development database using `alembic upgrade head`
- [ ] **2. Create SQLAlchemy ORM Model (AC: #1)** [Depends on: Task 1]
    - [ ] Create `WorkItem` model in `backend/app/domains/models/work_item.py`
    - [ ] Define relationships to Team, User (author), User (assignee), Sprint models
    - [ ] Implement proper enum classes for `type` and `status` fields
    - [ ] Add model validation using Pydantic validators where appropriate
    - [ ] Export model in `backend/app/domains/models/__init__.py`
- [ ] **3. Create Pydantic Schemas (AC: #1)** [Depends on: Task 2]
    - [ ] Create request/response schemas in `backend/app/domains/schemas/work_item.py`
    - [ ] Implement `WorkItemCreateRequest`, `WorkItemUpdateRequest`, `WorkItemResponse` schemas
    - [ ] Add proper field validation and type hints following coding standards
    - [ ] Export schemas in `backend/app/domains/schemas/__init__.py`
- [ ] **4. Update Database Schema Documentation (AC: #2)** [Depends on: Task 1]
    - [ ] Update `docs/architecture/8-database-schema.md` with work_items table definition
    - [ ] Document relationships and foreign key constraints
    - [ ] Add indexing strategy documentation
    - [ ] Update entity relationship diagrams if present
- [ ] **5. Create Unit Tests for Models and Schemas (AC: #2)** [Depends on: Tasks 2, 3]
    - [ ] Write unit tests for WorkItem model in `backend/tests/unit/test_work_item_model.py`
    - [ ] Write unit tests for WorkItem schemas in `backend/tests/unit/test_work_item_schemas.py`
    - [ ] Test model relationships and constraints
    - [ ] Test schema validation rules and edge cases
    - [ ] Achieve minimum 80% test coverage for new code

## Dev Notes

### Data Models
- The `WorkItem` model represents a single, atomic unit of work in the backlog (user story, bug, or task)
- **Key Attributes from architecture**: `id` (UUID), `teamId` (FK), `sprintId` (FK, nullable), `authorId` (FK), `assigneeId` (FK, nullable), `type` (enum: 'story', 'bug', 'task'), `title` (string), `description` (string, nullable), `status` (enum: 'backlog', 'todo', 'in_progress', 'done', 'archived'), `priority` (float), `storyPoints` (integer, nullable), `completedAt` (Date, nullable), `created_at` (Date), `updated_at` (Date), `sourceSprintIdForActionItem` (FK, nullable)
- **Sprint Dependencies**: Sprint model is defined in architecture but will be implemented in Epic 4. Sprint-related fields (sprintId, sourceSprintIdForActionItem) are nullable to allow work items to exist in backlog before sprints are created
- **Field Explanations**: `sourceSprintIdForActionItem` tracks which sprint generated this work item as an action item during retrospectives
- Foreign key relationships: Team (1:Many), User as author (1:Many), User as assignee (1:Many), Sprint (1:Many, future implementation)
- *[Source: docs/architecture/4-data-models.md]*

### Database Architecture
- PostgreSQL database with UUID primary keys following established patterns
- Foreign key relationships between work_items, teams, users, and sprints tables
- Database migrations managed via Alembic (established in Story 1.2)
- Proper indexing required on team_id, status, and priority columns for performance
- *[Source: docs/architecture/8-database-schema.md, docs/architecture/10-backend-architecture.md]*

### Backend Architecture
- WorkItem model will follow the Repository Pattern established in previous stories
- Use SQLAlchemy ORM with proper async patterns from existing codebase
- Dependency injection pattern will be followed for service layer (future stories)
- Follow same database connection patterns established in Story 1.4-1.7
- *[Source: docs/architecture/10-backend-architecture.md, stories/1.7.invite_users_to_team.md]*

### File Locations
- WorkItem Model: `backend/app/domains/models/work_item.py`
- WorkItem Schemas: `backend/app/domains/schemas/work_item.py`
- Database Migration: `backend/alembic/versions/{timestamp}_add_work_items_table.py`
- Database Schema Documentation: `docs/architecture/8-database-schema.md`
- Unit Tests (Models): `backend/tests/unit/test_work_item_model.py`
- Unit Tests (Schemas): `backend/tests/unit/test_work_item_schemas.py`
- *[Source: docs/architecture/coding-standards.md, existing project structure]*

### Local Supabase Usage Rules
- Use local Supabase instance for database management
- Supabase CLI and Supabase MCP are available for managing database operations
- Follow established migration patterns using Alembic (not Supabase migrations)
- Continue using existing FastAPI + PostgreSQL patterns rather than Supabase Auth or RPC
- *[Source: User Rules - Local Supabase Preference]*

### Database Naming Conventions
- All database tables use snake_case naming (work_items)
- All database columns use snake_case naming (team_id, created_at)
- Backend Python code uses snake_case for variables and functions
- Primary keys are UUIDs following established patterns
- *[Source: docs/architecture/coding-standards.md]*

### Security Considerations
- UUID primary keys provide non-enumerable IDs for security
- Foreign key constraints ensure data integrity
- SQL injection prevention via parameterized queries (SQLAlchemy ORM)
- Input validation through Pydantic schemas with proper field constraints
- *[Source: docs/architecture/coding-standards.md#security-best-practices]*

### Performance Considerations
- Database indexes on team_id for team-based queries
- Index on status column for filtering by work item status
- Index on priority column for ordering and filtering
- Nullable sprint_id allows work items to exist in backlog without sprint assignment
- *[Source: docs/architecture/4-data-models.md, docs/architecture/8-database-schema.md]*

### Previous Story Context
- Database connection patterns established in Stories 1.4-1.7
- UUID primary key patterns established in User, Team, TeamMember, and Invitation models
- Alembic migration patterns established in Story 1.2
- SQLAlchemy ORM and Pydantic schema patterns established in Stories 1.4-1.7
- *[Source: stories/1.2.setup_database_migrations.md, stories/1.4.user_registration.md, stories/1.7.invite_users_to_team.md]*

## Testing

### Backend Testing Requirements
- **Unit Tests**: Test WorkItem model attributes, relationships, and constraints
- **Unit Tests**: Test WorkItem Pydantic schemas validation rules and serialization
- **Test Files**: `backend/tests/unit/test_work_item_model.py`, `backend/tests/unit/test_work_item_schemas.py`
- **Coverage**: Minimum 80% coverage for new model and schema code
- **Framework**: pytest with async support for database operations
- **Mock Strategy**: Use existing database fixtures and patterns from previous stories

### Testing Standards from Architecture
- Test file location: `backend/tests/unit/` for unit tests
- Testing frameworks: pytest for backend testing
- Use existing authentication and database fixtures from Stories 1.4-1.7
- Follow established testing patterns for models and schemas
- *[Source: docs/architecture/coding-standards.md#testing-requirements]*

## Change Log
| Date | Version | Description | Author |
| :--- | :--- | :--- | :--- |
| 2025-09-17 | 1.0 | Initial draft of create work item schema story. | Bob (SM) |
|| 2025-09-17 | 1.1 | PO validation completed. Fixed AC #1 (removed story_points table reference), clarified Sprint dependencies, added field explanations. | Sarah (PO) |

## QA Results

### Pre-Implementation Review Date: 2025-09-17

### Reviewed By: Quinn (Test Architect)

### Quality Gate Assessment: PRE-IMPLEMENTATION VALIDATION

**Review Type**: Pre-implementation test strategy and requirements validation
**Story Status**: Draft ‚Üí Ready for Development

### Requirements Traceability Analysis ‚úÖ

**AC Coverage Mapping (Given-When-Then)**:

**AC1**: Database migration for `work_items` table
- **Given**: Developer has Alembic configured and database access
- **When**: Migration is created and applied with required schema
- **Then**: `work_items` table exists with all specified fields and constraints
- **Test Coverage**: Database schema validation in integration tests

**AC2**: Schema applied to database
- **Given**: Migration has been created and tested
- **When**: `alembic upgrade head` is executed
- **Then**: Database schema reflects all work_items table changes
- **Test Coverage**: Migration rollback/forward tests, schema introspection tests

**Coverage Assessment**: ‚úÖ **COMPLETE** - All ACs have clear test strategies

### Test Architecture Review ‚úÖ

**Testing Levels Appropriateness**:
- **Unit Tests**: ‚úÖ Model validation, schema serialization, enum constraints
- **Integration Tests**: ‚úÖ Database operations, migration scripts, FK relationships
- **Schema Tests**: ‚úÖ Migration forward/rollback, constraint validation
- **E2E Considerations**: Not applicable for schema-only story

**Test Coverage Strategy**: ‚úÖ **EXCELLENT**
- Backend: 80% coverage requirement specified
- Model Tests: Relationships, validation, constraints
- Schema Tests: Pydantic validation, serialization/deserialization
- Migration Tests: Forward/backward compatibility, data integrity

**Mock Strategy Validation**: ‚úÖ **APPROPRIATE**
- Database fixtures from existing stories
- Async testing patterns established
- No external service mocking needed for schema story

### Security Risk Assessment ‚úÖ

**Data Model Security**: ‚úÖ **ROBUST**
- UUID primary keys (non-enumerable)
- Proper foreign key constraints
- Nullable fields appropriately defined

**Input Validation**: ‚úÖ **COMPREHENSIVE**
- Pydantic schema validation planned
- Enum constraints for type and status fields
- Field length and format validation

**SQL Security**: ‚úÖ **ADEQUATE**
- SQLAlchemy ORM prevents injection
- Parameterized queries via Repository Pattern
- No raw SQL in schema definition

**Risk Score**: **LOW** (Score: 2/10)

### Performance Considerations ‚úÖ

**Database Design**: ‚úÖ **OPTIMIZED**
- Proper indexing strategy on team_id, status, priority
- UUID primary keys for performance and security
- Nullable foreign keys for future Sprint relationships

**Query Performance**: ‚úÖ **WELL-PLANNED**
- Indexes on most frequently queried columns
- Efficient relationship definitions
- Consideration for future backlog size scaling

### Technical Debt Assessment ‚úÖ

**Architecture Compliance**: ‚úÖ **EXCELLENT**
- Follows established patterns from Stories 1.4-1.7
- Repository Pattern maintained
- Alembic migration strategy consistent

**Code Quality Indicators**: ‚úÖ **HIGH CONFIDENCE**
- Comprehensive Dev Notes with source references
- Clear separation of concerns (model/schema/migration)
- Proper file organization following project structure

**Future Considerations**: üìù **WELL-DOCUMENTED**
- Sprint relationships deferred appropriately to Epic 4
- Action item tracking via sourceSprintIdForActionItem planned
- Performance indexing strategy documented

### NFR Validation

**Security**: ‚úÖ **PASS**
- Non-enumerable UUIDs, proper constraints, input validation

**Performance**: ‚úÖ **PASS** 
- Efficient indexing strategy, appropriate data types

**Reliability**: ‚úÖ **PASS**
- Migration rollback capability, foreign key constraints

**Maintainability**: ‚úÖ **PASS**
- Clear documentation, established patterns, proper structure

### Critical Risk Factors: NONE IDENTIFIED ‚úÖ

**No blocking issues found**:
- No high-risk security vulnerabilities
- No performance concerns for expected data volumes
- No architectural violations
- No missing critical test scenarios

### Testability Assessment ‚úÖ

**Controllability**: ‚úÖ **HIGH**
- Database state fully controllable via fixtures
- Migration scripts deterministic
- Model relationships testable in isolation

**Observability**: ‚úÖ **HIGH**
- Database schema introspectable
- Model validation errors clear and specific
- Migration status trackable

**Debuggability**: ‚úÖ **HIGH**
- Clear error messages from Pydantic validation
- SQLAlchemy ORM provides detailed error context
- Migration scripts have clear naming conventions

### Development Readiness Score: 95/100 ‚úÖ

**Scoring Breakdown**:
- Requirements Clarity: 20/20
- Test Strategy: 20/20
- Architecture Alignment: 20/20
- Security Considerations: 18/20 (excellent but could specify exact validation rules)
- Technical Documentation: 17/20 (comprehensive but could add sequence diagrams)

### Quality Gate Status: ‚úÖ **PASS**

**Gate Decision**: **APPROVED FOR DEVELOPMENT**

**Confidence Level**: **HIGH** for successful implementation

### Recommendations for Development Team

**Immediate (Must Address)**:
- Follow exact task sequence (1‚Üí2‚Üí3‚Üí4‚Üí5) due to dependencies
- Implement comprehensive enum validation in both SQLAlchemy and Pydantic
- Ensure migration includes all specified indexes for performance

**Future Enhancements (Post-Implementation)**:
- Consider adding database-level check constraints for data quality
- Plan for eventual Sprint FK constraint addition in Epic 4
- Design for potential work item archival/soft delete patterns

### Files to Monitor During Development

**High-Risk Files** (require extra QA attention):
- Database migration file (schema critical)
- WorkItem model relationships (data integrity)
- Enum definitions (business logic critical)

**Test Files to Validate**:
- All specified test files must achieve stated coverage
- Migration forward/rollback tests essential
- Comprehensive model relationship testing required

### Gate Status

Gate: PASS ‚Üí docs/qa/gates/2.1-create-work-item-schema.yml
